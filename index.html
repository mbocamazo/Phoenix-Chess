<!DOCTYPE html>
<html>

  <head>
    <meta charset='utf-8' />
    <meta http-equiv="X-UA-Compatible" content="chrome=1" />
    <meta name="description" content="Phoenix-Chess : Chess AI created for Software Design Final Project" />

    <link rel="stylesheet" type="text/css" media="screen" href="stylesheets/stylesheet.css">

    <title>Phoenix-Chess</title>
  </head>

  <body>

    <!-- HEADER -->
    <div id="header_wrap" class="outer">
        <header class="inner">
          <a id="forkme_banner" href="https://github.com/mbocamazo/Phoenix-Chess">View on GitHub</a>

          <h1 id="project_title">Phoenix-Chess</h1>
          <h2 id="project_tagline">Chess AI created for Software Design Final Project</h2>

            <section id="downloads">
              <a class="zip_download_link" href="https://github.com/mbocamazo/Phoenix-Chess/zipball/master">Download this project as a .zip file</a>
              <a class="tar_download_link" href="https://github.com/mbocamazo/Phoenix-Chess/tarball/master">Download this project as a tar.gz file</a>
            </section>
        </header>
    </div>

    <!-- MAIN CONTENT -->
    <div id="main_content_wrap" class="outer">
      <section id="main_content" class="inner">
        <p>This is the project page for Phoenix-Chess, a Chess AI written by Michael Bocamazo (<a href="https://github.com/mbocamazo" class="user-mention">@mbocamazo</a>) and Dennis Chen (<a href="https://github.com/dennis-chen" class="user-mention">@dennis-chen</a>) for Software Design Spring 2014, Olin College of Engineering.</p>

<p>Project Proposal:</p>

<p>The plan for Phoenix-Chess is to create a chess AI that can be refined and extended with machine learning techniques.  We will adopt the standard tree-search, minimaxing, alpha-beta pruning structure; implementation of these elements is the Software Engineering work.  The original AI design and CS work will come in when constructing the board evaluation function and pruning heuristics.  The board evaluation function will quantify material, activity of pieces, pawn value, pawn structure, board control, king safety, initiative, and a few features of the board state common to both players such as volatility, and an open/closed position.  Material, activity, and board control can have interrelated evaluations that dynamically weight the pieces.  The pruning function will eliminate branches that are judged to have a low probability of viability to speed tree search and thus allow for deeper evaluations.  We will also need to add a function to limit the search depth based on time available.  Once this groundwork has been laid, we can refine the weights of our board evaluation and pruning functions using machine learning, such as simple hill-climbing or possibly genetic algorithms with the extension of constructing new features.  We could also access master game databases and refine the weights to best approximate master level moves given a certain position.  If these tasks are done satisfactorily, we can try to add an opening book.  The greatest challenges we envision are the feature construction from primitive relationships between game elements, and interaction and analysis with game databases.</p>

<p>If we were to have an Angel Adviser, it would be best if they had experience with AI, chess, or ML.</p>

<p>Our proposed deliverables can be broken down as follows:</p>

<p>Minimum Deliverable: A chess board evaluation function/tree search shell that searches at least 4 total moves ahead when making it’s choices. </p>

<p>Second Deliverable: Tree search pruning heuristic (suitable for machine learning)</p>

<p>Third Deliverable: Use ML to refine board weight function</p>

<p>Fourth Deliverable: Search and learn on databases of master level games to refine the board weight function</p>

<p>Fifth Deliverable: Use genetic algorithms to construct features within the board weight functions</p>

<p>Further extensions: iterate from deliverables 2 through 5 to improve the program.  Add an opening book.</p>

<p>The first step is to create an AI that does an exhaustive search at a certain depth with a basic board evaluation function.</p>

<p>This project will be done by Michael Bocamazo and Dennis Chen without collaboration from other groups.  The project repo is connected to this page at <a href="https://github.com/mbocamazo/Phoenix-Chess">https://github.com/mbocamazo/Phoenix-Chess</a>.</p>

<p></p>
<p>




Design</p>
<p> To get started on our project, the first thing to do was to find a working python chess implementation. We settled on using the most complete chess implementation we could find because a chess AI that can't deal with castling, pawn promotion, and en passant isn't a terribly useful AI. The trade-off was speed and that the code had no implementation for AI and was not done in an Object-Oriented Way. We decided that dealing with this was better than implementing castling, pawn promotion, etc. ourselves.</p>
<p>We've spent the last two weeks refactoring the previous code into a MVC model to make it easier to interface with. We then implemented a way for two chess AIs to play against each other. We got AIs that made random moves to play against each other without a problem. We're currently trying to implement tree search for the AI. (Tree search is the standard textbook way of having AI decide on the next move in a chess game). The interesting space where we'll start to make algorithm and design decisions is in the future, when we write “pruning” and “quiescence” functions that determine when to search deeper into the tree (look further into the possible future moves) and when to stop looking any further. Writing complex “board evaluation” functions, which the AI uses to determine how “good” a board is for itself, is a possibility as well.</p>
<p> Our most significant design decision so far was in choosing the chess implementation, which determines the speed of our chess program and thus how far our AI can look into the game tree. It is a inefficient implementation, not written for speed, but it's the best one complete one we found. It looks like not many people do serious chess AI work in python because it's a higher level and slower language. It's okay for us though, we aren't planning on writing a competitive Chess AI. Instead, the main goal is to explore how Chess AI can be programmed with Machine Learning (ML).</p>
<p> We kept our goal of ML in mind when implementing the tree search algorithm: Chess Ais take board evaluation, pruning and quiescence functions as input when they are instantiated. This way, for genetic algorithms, we can initialize Chess Ais with differently weighted pruning, quiescence, and board evaluation functions.       </p>
<p> Our development plan is to get tree search working, get a basic (and textbook) pruning algorithm called alpha-beta pruning working, and to look into the possibility of implementing data structures called transposition tables that can save a lot of time by having the AI “remember” board states that occur frequently. (Transposition tables are pretty complex to implement so we might ignore it in the interest of getting to the ML part of the project). Finally, we'll implement a basic quiescence function. At that point, we'll have our minimum deliverable, a not-terrible Chess AI. We think we want to use ML to dynamically change the board evaluation function as a game progresses, but the ML direction isn't set in stone yet. Both team members have been involved in coding and making design decisions and we'll continue to do so and pair program.  </p>

      </section>
    </div>

    <!-- FOOTER  -->
    <div id="footer_wrap" class="outer">
      <footer class="inner">
        <p class="copyright">Phoenix-Chess maintained by <a href="https://github.com/mbocamazo">mbocamazo</a> and <a href="https://github.com/dennis-chen">dennis-chen</a></p>
        <p>Published with <a href="http://pages.github.com">GitHub Pages</a></p>
      </footer>
    </div>

<p>UML Class Diagram</p>
<p>To implement genetic algorithms, we created tournament and game classes to have AI compete against each other. Our tournaments take a swiss tournament form, where the best AI are paired
  against each other, and the ranking of the AI player is modified based on how many games it wins or loses. We refactored the code that the original author of the chess program wrote in order to
  put it into a nice MVC model. Then we built in AI and human player classes and the classes needed for genetic algorithms mentioned earlier. AI are differentiated by the randomized
  board evaluation functions and search extension functions that they achieve. Those functions control how the AI quantifies how "good" a board is for either player, and also determines how deep
  the AI will search into the game tree.
</p>
    

  </body>
</html>
